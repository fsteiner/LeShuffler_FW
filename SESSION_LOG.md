# LeShuffler Development Session Log

This document contains the full development history for the LeShuffler encrypted bootloader project.
For quick reference and working practices, see `CLAUDE.md`.

---

## Original Brief

BRIEF FOR CLAUDE

I have developed an application to run on an automatic card shuffling device based on a STM32H733VGT6

You can find a version of the code files in the folder ending in 1.24. (Version A)

This version is flashed via ST Link using STM32CubeProgrammer.



I want to develop a version that can be:

1 Updated in the field by the USER via USB using a serial port from PC or Mac without the need for a ST Link

2 That will be signed and encrypted to prevent reverse engineering and guarantee authenticity



I have developed a version of such firmware (version B). Code, instructions and comments are in the folder Encrypted\_Bootloader.
The application firmware is a different version but this should not matter, the point of focus is the linker files, startup files and other "technical" files rather than the application files themselves

This version is not satisfying for 2 reasons:

3 it needs the user to press a switch on PCB which is not accessible to them

4 the Tera Term app and protocol used are not stable - the procedure described in the files works only for very small files but fails for my actual app



As a backup, I asked Claude to develop a way to flash firmware in the field via USB but without encryption.
This was done by developing a custom bootloader, the code of the bootloader and all explanations can be found in the folder "Bootload Test" along with a firmware updater in python and some other test files in python. The bootloader mode can be triggered in-app without the nee to access a switch. Also documentation generated by claude (all .md files with names in ALLCAPS). The version used here is in the folder ending in 1.21 (Version C), changes were made in the linker file, startup file etc.



This Version C works well but lacks encryption.



I would like Claude to:

5 Use the available elements to create a solution D that provides encryption - such as version B - with the convenience of transmission and the in-app triggering of version B

6 This solution will be tested with full access via ST LINK

7 Once validated, remove via ST LINK will be permanently blocked

8 I will need detailed instructions to go from version A to version D

9 I would like this file (CLAUDE.MD) to be automatically updated during the conversation, below the dotted line (keeping the "BRIEF" at all times)

---
## SESSION LOG - Version D Development

### 2025-11-28: Initial Implementation

#### Completed Tasks:
1. **Analyzed existing versions** (A, B, C)
2. **Designed Version D architecture**:
   - AES-256-CBC encryption (hardware accelerated)
   - ECDSA-P256 signature verification
   - USB CDC transfer (from Version C)
   - In-app bootloader triggering (RTC backup register)

3. **Created Version D folder structure**:
   ```
   Version_D_Encrypted_USB_Bootloader/
   ‚îú‚îÄ‚îÄ Bootloader/         (modified from Version C)
   ‚îú‚îÄ‚îÄ Tools/              (Python tools)
   ‚îú‚îÄ‚îÄ Keys/test/          (test keys)
   ‚îî‚îÄ‚îÄ Keys/production/    (empty - generate before release)
   ```

4. **Created Tools**:
   - `encrypt_firmware.py` - Developer tool to create .sfu files
   - `firmware_updater.py` - User tool to upload .sfu files
   - `generate_keys.py` - Key generation utility

5. **Created Bootloader crypto module**:
   - `crypto.h` / `crypto.c` - AES decryption, SHA-256 hashing
   - `crypto_keys.h` - Test keys (ECDSA public + AES)
   - Modified `bootload.c` for encrypted packets

6. **Created test keys**:
   - ECDSA key pair (from Version B)
   - AES-256 test key

#### Key Decisions Made:
- **Key storage**: AES key hardcoded in bootloader flash, protected by RDP
- **ECDSA private key**: Never on device (only public key)
- **File format**: `.sfu` (Secure Firmware Update) with magic "LSFU"
- **Encryption separate from upload**: User only gets pre-encrypted .sfu file

#### TODO (Next Steps):
1. Add CRYP and HASH peripherals to .ioc file via STM32CubeMX
2. Add micro-ecc library for ECDSA verification
3. Create test application (simple "hello world" with same peripherals)
4. Test full encrypted update cycle
5. Generate production keys and test
6. Document RDP Level 1/2 activation procedure

#### Files Created:
- `Version_D_Encrypted_USB_Bootloader/README.md`
- `Version_D_Encrypted_USB_Bootloader/Tools/encrypt_firmware.py`
- `Version_D_Encrypted_USB_Bootloader/Tools/firmware_updater.py`
- `Version_D_Encrypted_USB_Bootloader/Tools/generate_keys.py`
- `Version_D_Encrypted_USB_Bootloader/Bootloader/Core/Inc/crypto.h`
- `Version_D_Encrypted_USB_Bootloader/Bootloader/Core/Inc/crypto_keys.h`
- `Version_D_Encrypted_USB_Bootloader/Bootloader/Core/Src/crypto.c`
- Modified: `Version_D_Encrypted_USB_Bootloader/Bootloader/Core/Src/bootload.c`
- Modified: `Version_D_Encrypted_USB_Bootloader/Bootloader/Core/Inc/bootload.h`

---

### 2025-11-28: Session 2 - STM32CubeIDE Project Issues (BLOCKED)

#### What Happened:
Attempted to integrate micro-ecc library for ECDSA verification but encountered persistent STM32CubeIDE project import issues.

#### Issues Encountered:
1. **Project .ioc files became corrupted** - "target is not supported" errors
2. **Multiple troubleshooting attempts failed**:
   - Fixed .cproject references
   - Tried copying working .ioc files - encoding issues with PowerShell
   - Deleted .metadata folders
   - Tried matching .ioc format to working projects
3. **Root cause unclear** - possibly duplicate project names in workspace, or file corruption during editing

#### Current State:
- **Version_D_Encrypted_USB_Bootloader folder is empty** (cleaned for fresh start)
- **Working source project**: `Bootload test\LeShuffler_Bootloader_Minimal` - this imports fine
- **micro-ecc library files prepared** (need to be added to new project):
  - `uECC.c` - main library (downloaded from GitHub)
  - `uECC.h` - header file
  - `uECC_config.h` - STM32H7 configuration (created, enables only P-256)
- **crypto.c implementation ready** - ECDSA verification code written

#### TO RESUME - Fresh Start Approach:

**Step 1: Create new project in STM32CubeIDE**
1. Open STM32CubeIDE
2. Use a DIFFERENT workspace (not Version_D folder) to avoid metadata issues
3. File ‚Üí New ‚Üí STM32 Project from Existing .ioc
4. Select: `Bootload test\LeShuffler_Bootloader_Minimal\LeShuffler_Bootloader_Minimal.ioc`
5. Keep name as `LeShuffler_Bootloader_Minimal` or use new name like `LeShuffler_Bootloader_V4`

**Step 2: Add crypto peripherals via CubeMX**
Open .ioc file and enable:
- CRYP (Crypto processor) - for AES-256-CBC
- HASH - for SHA-256
- RNG (Random Number Generator) - for micro-ecc

**Step 3: Generate code**
Save .ioc and generate code

**Step 4: Add micro-ecc library**
Copy these files to the project:
- `uECC.c` ‚Üí Core/Src/
- `uECC.h` ‚Üí Core/Inc/
- `uECC_config.h` ‚Üí Core/Inc/

**Step 5: Add crypto implementation**
- `crypto.c` ‚Üí Core/Src/
- `crypto.h` ‚Üí Core/Inc/
- `crypto_keys.h` ‚Üí Core/Inc/

**Step 6: Update bootload.c**
Integrate encrypted packet handling

**Step 7: Build and test**

#### Key Code to Preserve (crypto.c ECDSA implementation):
```c
#include "uECC.h"

static int uECC_RNG_Callback(uint8_t *dest, unsigned size) {
    uint32_t random_word;
    unsigned i = 0;
    while (i < size) {
        if (HAL_RNG_GenerateRandomNumber(&hrng, &random_word) != HAL_OK) {
            return 0;
        }
        unsigned bytes_to_copy = (size - i > 4) ? 4 : size - i;
        memcpy(&dest[i], &random_word, bytes_to_copy);
        i += bytes_to_copy;
    }
    return 1;
}

int32_t Crypto_ECDSA_Verify(const uint8_t *data, uint32_t data_length, const uint8_t *signature) {
    uint8_t hash[SHA256_DIGEST_SIZE];
    if (Crypto_SHA256(data, data_length, hash) != CRYPTO_OK) return CRYPTO_ERROR;
    const struct uECC_Curve_t *curve = uECC_secp256r1();
    if (uECC_verify(ECDSA_PUBLIC_KEY, hash, sizeof(hash), signature, curve)) {
        return CRYPTO_OK;
    }
    return CRYPTO_INVALID_SIG;
}
```

#### uECC_config.h content:
```c
#ifndef UECC_CONFIG_H
#define UECC_CONFIG_H

#define uECC_SUPPORTS_secp160r1  0
#define uECC_SUPPORTS_secp192r1  0
#define uECC_SUPPORTS_secp224r1  0
#define uECC_SUPPORTS_secp256r1  1
#define uECC_SUPPORTS_secp256k1  0

#define uECC_PLATFORM           uECC_arm_thumb2
#define uECC_WORD_SIZE          4
#define uECC_ARM_USE_UMAAL      1
#define uECC_OPTIMIZATION_LEVEL 3
#define uECC_SQUARE_FUNC        1
#define uECC_SUPPORT_COMPRESSED_POINT 0
#define uECC_VLI_NATIVE_LITTLE_ENDIAN 0
#define uECC_ENABLE_VLI_API     0
#define uECC_RNG_MAX_TRIES      64

#endif
```

---

### 2025-01-02: Session 3 - Bootloader v2 & Safe Update Protocol

#### Problem Identified:
USB disconnects during firmware transfer could cause flash corruption on v1 bootloader:
- v1 only erases flash once at bootloader entry
- If USB disconnects mid-transfer and script retries, new data is written over partially-written flash
- STM32 NOR flash: can only change 1‚Üí0, not 0‚Üí1 without erase
- Result: `old_data AND new_data` = corrupted firmware = bricked device

#### Solution Implemented:

**Bootloader v2** (new protocol):
1. `PACKET_TYPE_STATUS = 0x04` - Query bootloader state (version, bytes received, etc.)
2. Always re-erase flash on START packet - enables safe restart-from-beginning
3. Removed `HAL_Delay(5)` - was causing USB disconnects on macOS
4. 24-byte status response with version, state, progress, flags

**Python Updater v5** (auto-detection):
1. Sends STATUS packet to detect bootloader version
2. **v2 detected**: Uses robust protocol, can safely restart up to 5 times
3. **v1 detected**: Zero retries - fails immediately on disconnect to prevent corruption
4. Clear messaging for users about power cycle requirement

#### Files Created/Modified:

**Version archive:**
```
Bootload test/Bootloader_Versions/
‚îú‚îÄ‚îÄ v1_shipped/          # Original bootloader (shipped devices)
‚îÇ   ‚îú‚îÄ‚îÄ bootload.c
‚îÇ   ‚îú‚îÄ‚îÄ bootload.h
‚îÇ   ‚îî‚îÄ‚îÄ usbd_cdc_if.c
‚îî‚îÄ‚îÄ v2_robust/           # New bootloader with safe restart
    ‚îú‚îÄ‚îÄ bootload.c
    ‚îú‚îÄ‚îÄ bootload.h
    ‚îî‚îÄ‚îÄ usbd_cdc_if.c
```

**Updated files in LeShuffler_Bootloader_Minimal/:**
- `Core/Inc/bootload.h` - Added STATUS packet, version constants, BootloaderStatus_t
- `Core/Src/bootload.c` - Always re-erase on START, removed HAL_Delay(5), STATUS handling
- `USB_DEVICE/App/usbd_cdc_if.c` - STATUS packet sends 24-byte response

**New Python updater:**
- `firmware_updater_v5.py` - Auto-detects version, safe behavior for both

#### Key Design Decisions:

| Scenario | v1 Behavior | v2.0 Behavior | v2.1 Behavior |
|----------|-------------|---------------|---------------|
| Normal transfer | Works | Works | Works |
| USB disconnect | Abort immediately | Restart from 0% | Resume from last position |
| Corruption risk | None (no retry) | None (re-erase) | None (no re-write) |

#### v2.1 Update: True Resume Capability

**Problem**: v2.0 restarts from beginning on disconnect (re-erases flash, loses progress)

**Solution**: Added `PACKET_TYPE_RESUME = 0x05` to continue interrupted transfers without re-erasing

**How it works**:
1. On USB disconnect, updater reconnects and queries STATUS
2. If `flags & 0x02` (transfer in progress) and `bytes_received > 0`:
   - Sends RESUME packet (no erase)
   - Continues from `bytes_received` offset
3. If RESUME fails or no valid state, falls back to START (re-erase)
4. **Unlimited resumes** - no retry limit since we always make progress

**Files modified**:
- `bootload.h`: Added `PACKET_TYPE_RESUME`, version bumped to 2.1
- `bootload.c`: Added RESUME packet handler
- `firmware_updater_v5_1.py`: v5.1 with resume logic (unlimited retries)

#### Testing Status (2025-01-02):
- **Windows + v1**: Works reliably, no disconnects
- **Windows + v2.1**: Works reliably
- **macOS + v2.1**: Works with resume - tested successfully with 1 disconnect, resumed and completed

#### SAFETY SUMMARY

| Bootloader | On USB Disconnect | Risk | Recovery |
|------------|-------------------|------|----------|
| **v2.1** (new machines) | Auto-resume from last position | **ZERO** | Automatic |
| **v1.0** (shipped machines) | Abort immediately | **ST-LINK required** | Manual flash via ST-LINK |

**CRITICAL v1.0 LIMITATION DISCOVERED (2025-01-02):**
- v1.0 erases flash **at bootloader entry** (when user presses "Firmware Update")
- Flash is already erased BEFORE updater connects
- If disconnect happens mid-transfer ‚Üí incomplete firmware with valid header
- Bootloader jumps to incomplete app ‚Üí device stuck
- **Cannot recover via USB** - requires ST-LINK to re-flash

**v1.0 Timeline:**
```
User presses "Firmware Update"
    ‚Üì
Bootloader starts ‚Üí FLASH ERASED IMMEDIATELY
    ‚Üì
3 short beeps + 1 long beep (USB ready)
    ‚Üì
User runs updater ‚Üí connects ‚Üí transfer begins
    ‚Üì
(No going back - must complete or ST-LINK)
```

#### v1.0 Safety Measures (firmware_updater_v5_1.py):

**1. macOS Blocked for v1.0:**
```
ERROR: Cannot update v1.0 bootloader on macOS
macOS has known USB stability issues...
Please use a Windows PC for this update.
```

**2. USB Stability Pre-Check (flash already erased, but checks before transfer):**
```
Verifying USB stability (5 tests)...
  Test 1/5... OK
  Test 2/5... OK
  ...
```
If any test fails ‚Üí warns user USB is unstable (but must still complete update somehow).

**3. Strong Warning + Confirmation (Windows):**
```
WARNING: Legacy bootloader (v1.0) detected
If USB disconnects during transfer:
  - The device will need ST-LINK to recover
Type 'yes' to proceed:
```

**Tested 2025-01-02:** Windows + v1.0 with all safety measures ‚Üí SUCCESS

#### firmware_updater_v5_1.py Features:
- Auto-detects bootloader version (v1.x, v2.0, v2.1)
- `verify_bootloader_connection()` check before transfer
- Shows clear error message if device not in bootloader mode
- USB tips only shown for USB-related failures
- **v2.1**: Unlimited resumes on disconnect (always makes progress)
- **v1.0**: macOS blocked, stability check, warning + confirmation, abort on disconnect

#### NEXT TASK: Create Windows Executable

**Goal**: Package `firmware_updater_v5_1.py` as a standalone Windows .exe using PyInstaller

**Steps**:
1. Install PyInstaller: `pip install pyinstaller`
2. Navigate to `Bootload test` folder
3. Run PyInstaller:
   ```
   pyinstaller --onefile --name "LeShuffler_Updater" firmware_updater_v5_1.py
   ```
4. The executable will be in `dist/LeShuffler_Updater.exe`
5. Test: Place `LeShuffler.bin` in same folder as .exe and run

**Distribution package** (for end users):
```
LeShuffler_Firmware_Update/
‚îú‚îÄ‚îÄ LeShuffler_Updater.exe    # The packaged executable
‚îú‚îÄ‚îÄ LeShuffler.bin            # The firmware file (you provide this)
‚îî‚îÄ‚îÄ README.txt                # Simple instructions
```

**Key points**:
- The .exe looks for `LeShuffler.bin` in the same directory
- User just double-clicks .exe, selects port, and update runs
- Windows only (macOS has USB stability issues)

#### To Switch Between Bootloader Versions:

**Use v1 (shipped version):**
```bash
cp "Bootloader_Versions/v1_shipped/"* "LeShuffler_Bootloader_Minimal/Core/Src/"
cp "Bootloader_Versions/v1_shipped/bootload.h" "LeShuffler_Bootloader_Minimal/Core/Inc/"
cp "Bootloader_Versions/v1_shipped/usbd_cdc_if.c" "LeShuffler_Bootloader_Minimal/USB_DEVICE/App/"
# Clean and rebuild in STM32CubeIDE
```

**Use v2 (robust version):**
```bash
cp "Bootloader_Versions/v2_robust/"* "LeShuffler_Bootloader_Minimal/Core/Src/"
cp "Bootloader_Versions/v2_robust/bootload.h" "LeShuffler_Bootloader_Minimal/Core/Inc/"
cp "Bootloader_Versions/v2_robust/usbd_cdc_if.c" "LeShuffler_Bootloader_Minimal/USB_DEVICE/App/"
# Clean and rebuild in STM32CubeIDE
```

---

### 2025-01-02: Session 4 - Windows Executable Created

#### Completed:
- **Built Windows executable** using PyInstaller 6.17.0
- **Created distribution package** at `Bootload test/LeShuffler_Firmware_Update/`:
  ```
  LeShuffler_Firmware_Update/
  ‚îú‚îÄ‚îÄ LeShuffler_Updater.exe    (8.2 MB)
  ‚îî‚îÄ‚îÄ README.txt                (user instructions)
  ```

#### To Distribute:
1. Copy the `LeShuffler_Firmware_Update` folder
2. Add your `LeShuffler.bin` firmware file to the folder
3. Zip and send to users

#### Build Artifacts (can be deleted):
- `Bootload test/build/` - PyInstaller temp files
- `Bootload test/dist/` - output folder (exe copied to distribution)
- `Bootload test/LeShuffler_Updater.spec` - PyInstaller spec file

---

### 2025-01-02: Session 5 - ST-LINK Factory Flasher Created

#### Completed:
- **Created ST-LINK flasher tool** (`stlink_flasher.py`) to flash bootloader + firmware via ST-LINK
- **Built Windows executable** (`LeShuffler_STLink_Flasher.exe`)
- Auto-detects installed STM32CubeProgrammer (required)

#### Distribution Package:
```
LeShuffler_Factory_Flash/              (~8 MB total)
‚îú‚îÄ‚îÄ LeShuffler_STLink_Flasher.exe      (8 MB)
‚îú‚îÄ‚îÄ Bootloader_E.bin                   (48 KB) -> 0x08000000
‚îú‚îÄ‚îÄ LeShuffler.bin                     (218 KB) -> 0x08020000
‚îî‚îÄ‚îÄ README.txt
```

#### Requirements:
- **STM32CubeProgrammer** must be installed (tool auto-detects installation path)
- Download from: https://www.st.com/en/development-tools/stm32cubeprog.html

#### Features:
- Auto-detects STM32CubeProgrammer installation
- Flashes both bootloader and firmware in one operation
- Supports RDP (Read Protection) levels 0, 1, 2
- Command line options for advanced use

#### Usage:
```
# Basic (flash both bootloader + firmware)
LeShuffler_STLink_Flasher.exe

# Firmware only (bootloader already installed)
LeShuffler_STLink_Flasher.exe --firmware-only

# Enable Read Protection Level 1 (production)
LeShuffler_STLink_Flasher.exe --rdp 1
```

#### Tested 2025-01-02:
- ST-LINK V2 + STM32H733VGT6 -> SUCCESS
- Bootloader verified at 0x08000000
- Firmware verified at 0x08020000

---

### Building Windows Executables from Python

#### Prerequisites:
```bash
pip install pyinstaller pyserial
```

#### Build Commands:

**USB Firmware Updater** (firmware_updater_v5_1.py):
```bash
cd "C:\Users\Francois\Dropbox\Documents\LeShuffler\Product_Design\Software\Bootload test"
python -m PyInstaller --onefile --name "LeShuffler_Updater" --collect-all serial --clean firmware_updater_v5_1.py
```
Output: `dist/LeShuffler_Updater.exe`

**ST-LINK Factory Flasher** (stlink_flasher.py):
```bash
cd "C:\Users\Francois\Dropbox\Documents\LeShuffler\Product_Design\Software\Bootload test"
python -m PyInstaller --onefile --name "LeShuffler_STLink_Flasher" --clean stlink_flasher.py
```
Output: `dist/LeShuffler_STLink_Flasher.exe`

#### Key PyInstaller Options:
- `--onefile` - Single executable (no folder with DLLs)
- `--name "Name"` - Output filename
- `--collect-all serial` - Include all pyserial modules (fixes ctypes DLL issues)
- `--clean` - Clean cache before building
- `--icon icon.ico` - Custom icon (optional)

#### After Building:
1. Copy exe from `dist/` to distribution folder
2. Add required data files (firmware binaries, etc.)
3. Test on a clean machine without Python installed

#### Troubleshooting PyInstaller:

**Error: "DLL load failed while importing _ctypes"**
- Cause: pyserial needs ctypes which has DLL dependencies
- Fix: Add `--collect-all serial` to the build command

**Window closes immediately on error**
- Cause: Script exits before user can read error
- Fix: Add these patterns to your Python script:

```python
# 1. Wrap imports that might fail
try:
    import serial
    import serial.tools.list_ports
except ImportError as e:
    print(f"ERROR: {e}")
    input("Press Enter to exit...")
    sys.exit(1)

# 2. Add global exception handler at end of script
if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(f"ERROR: {e}")
        input("Press Enter to exit...")
        sys.exit(1)

# 3. Add input() before every sys.exit()
print("Done!")
input("Press Enter to exit...")
sys.exit(0)
```

**Finding script directory in exe (for locating data files)**
```python
def get_app_dir():
    """Works for both script and PyInstaller exe"""
    if getattr(sys, 'frozen', False):
        # Running as compiled exe
        return os.path.dirname(sys.executable)
    else:
        # Running as script
        return os.path.dirname(os.path.abspath(__file__))

# Usage: find firmware file next to exe
firmware_path = os.path.join(get_app_dir(), "LeShuffler.bin")
```

#### Build Artifacts (can be deleted after build):
- `build/` - PyInstaller temp files
- `dist/` - Output folder (copy exe from here)
- `*.spec` - PyInstaller spec file (can customize for advanced builds)

---

### 2025-01-03: Session 6 - Bootloader v2.1 Fix & Git Repo Consolidation

#### Problem Discovered:
The v2.1 bootloader was NOT actually preventing flash erase at entry. The issue:
- `bootload.c` had RESUME packet support and erase-on-START logic
- BUT `main.c` was erasing flash BEFORE USB init: `EraseApplicationFlash()` at line 135
- This meant entering bootloader mode always erased flash, regardless of protocol version

**Root cause in main.c:**
```c
// OLD CODE (erases whenever bootloader_requested, even if app valid)
if (bootloader_requested || !application_valid) {
    ...
    EraseApplicationFlash();  // ALWAYS erased here!
    ...
}
```

#### Fix Applied:
Modified `Bootloader/Core/Src/main.c` to only erase if app is ALREADY invalid:
```c
// NEW CODE (v2.1 - only erase if app already invalid)
if (bootloader_requested || !application_valid) {
    // 3 short beeps...

    // Only erase if app is ALREADY invalid (nothing to lose)
    // If app is valid, erase happens on START packet in ProcessFirmwarePacket()
    if (!application_valid) {
        EraseApplicationFlash();
    }

    // 1 long beep...
}
```

#### Git Repository Consolidation:
Moved bootloader and tools into the main firmware git repo for version control:

**Repository structure:**
```
LeShuffler_FW/LeShuffler/          (git repo)
‚îú‚îÄ‚îÄ Bootloader/                     # Bootloader v2.1 project
‚îÇ   ‚îú‚îÄ‚îÄ Core/Src/main.c            # Fixed erase logic
‚îÇ   ‚îú‚îÄ‚îÄ Core/Src/bootload.c        # RESUME packet support
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Tools/
‚îÇ   ‚îú‚îÄ‚îÄ firmware_updater_v5_1.py   # USB updater with v2.1 support
‚îÇ   ‚îî‚îÄ‚îÄ stlink_flasher.py          # Factory ST-LINK flasher
‚îú‚îÄ‚îÄ Core/                           # Application firmware
‚îî‚îÄ‚îÄ ...
```

**Commits created:**
| Commit | Description |
|--------|-------------|
| `aaf129d` | Add bootloader v2.0 (baseline before v2.1 fix) |
| `e6dc06d` | Bootloader v2.1: Don't erase flash at entry if app is valid |
| `dd83d8e` | Add firmware updater tools |

#### Testing Confirmed:
1. Enter bootloader mode (3 beeps + 1 long beep)
2. Power cycle WITHOUT running updater
3. Device returns to application ‚úì

#### ST-LINK Troubleshooting Notes:
- If `mode=UR` (Under Reset) fails with "Unable to get core ID":
  - NRST line may not be connected
  - Use `mode=HotPlug` instead: `STM32_Programmer_CLI -c port=SWD mode=HotPlug ...`
- HotPlug doesn't require NRST connection

#### Folder Renamed:
- Old: `LS FW V1.00`
- New: `LeShuffler_FW` (matches GitHub repo name)

---

    uint32_t checksum;
} bootloader_version_info = {
    .version = BOOTLOADER_VERSION,
    .magic = 0x424C5652,
    ...
};
```

**3. Application Header** (`Core/Inc/bootload.h`):
```c
#define BOOTLOADER_VERSION_ADDR   0x0800BFF0
#define BOOTLOADER_VERSION_MAGIC  0x424C5652

uint16_t GetBootloaderVersion(void);
```

**4. Application Function** (`Core/Src/bootload.c`):
```c
uint16_t GetBootloaderVersion(void) {
    uint32_t magic = *(volatile uint32_t*)(BOOTLOADER_VERSION_ADDR + 4);
    if (magic != BOOTLOADER_VERSION_MAGIC) {
        return 0;  // Old bootloader
    }
    return *(volatile uint16_t*)BOOTLOADER_VERSION_ADDR;
}
```

#### Usage in Firmware:
```c
uint16_t bl_ver = GetBootloaderVersion();
if (bl_ver == 0) {
    // Old bootloader without version info
} else {
    uint8_t major = bl_ver >> 8;    // e.g., 2
    uint8_t minor = bl_ver & 0xFF;  // e.g., 1
    // v2.1 = 0x0201
}
```

#### Commit:
- `cfdd579` - Add bootloader version at fixed flash address (0x0800BFF0)

#### Notes:
- Version is stored at last 16 bytes of bootloader flash (48KB ends at 0x0800BFFF)
- Magic value "BLVR" allows detection of old bootloaders (returns 0)
- Requires re-flashing bootloader for version to be readable

#### Additional Changes:
- Fixed `.cproject` linker path (was hardcoded to old location)
- Added `GetBootloaderVersion()` display in `prompt_firmware_version()` (interface.c)
- Commit amended to: `ba10b4f`

---

### 2025-01-05: Session 8 - Encrypted Bootloader Planning

#### Objective:
Plan development of Version D - encrypted USB bootloader

#### Key Decisions:

1. **NOT using SBSFU** - Custom lightweight solution extending Version C bootloader
2. **Naming convention**: `_E` suffix (e.g., `Bootloader_E`, `firmware_updater_E.py`)
3. **Hardware crypto**: STM32H7 CRYP (AES) + HASH (SHA-256) - need to enable in CubeMX
4. **Software crypto**: micro-ecc library for ECDSA (STM32H733 has no PKA)

#### Hardware Crypto Status (verified):
| Peripheral | Bootloader | Main App | Status |
|------------|------------|----------|--------|
| CRYP | Not enabled | Not enabled | **Must add** |
| HASH | Not enabled | Not enabled | **Must add** |
| RNG | Referenced | Enabled | OK |

#### Architecture:
```
Developer: encrypt_firmware.py ‚Üí .sfu file (signed + encrypted)
User: firmware_updater_E.py ‚Üí USB transfer
Device: Bootloader_E ‚Üí verify signature, decrypt, flash
```

#### Git Structure:
- Branch `encrypted` for Version D development
- `Bootloader/` = non-encrypted (existing machines)
- `Bootloader_E/` = encrypted (new machines)
- Shared `Core/` application code

#### Implementation Phases:
1. Setup & crypto peripherals (CubeMX + micro-ecc)
2. Encrypted protocol (.sfu format + modified bootload.c)
3. Testing & integration
4. Production keys
5. Security lockdown (RDP Level 2 - IRREVERSIBLE)

#### Files Created:
- `ENCRYPTED_BOOTLOADER_PLAN.md` - Detailed implementation plan

#### Learnings from SBSFU Q&A (conceptual, not direct config):
- Final lock (RDP Level 2) is irreversible but doesn't break OTA
- Watchdog timeout must match between bootloader and app
- Power-fail protection needed (our v2.1 resume handles this)

#### Reference Documents:
- `Encrypted_Bootloader/Q&A.rtf` - SBSFU-specific (conceptual reference only)
- Previous crypto code preserved in CLAUDE.md Session 2 (lines 172-222)

#### Watchdog Status (discovered):
- IWDG configured in `.ioc` but code never generated
- No `HAL_IWDG_Refresh()` calls anywhere
- Added as Phase 0 (preliminary step)

#### Updated Implementation Phases:
0. **Watchdog** - Add 5-sec IWDG, refresh in all waiting loops
1. Setup & crypto peripherals
2. Encrypted protocol
3. Testing
4. Production keys
5. Security lockdown (RDP Level 2)

#### Next Steps:
- User approval of plan
- Phase 0: Implement watchdog (5 sec, refresh in loops)
- Phase 1: Create `encrypted` branch, enable CRYP/HASH

---

### 2025-01-05: Session 9 - Watchdog Implementation (Phase 0)

#### Completed:

**1. Created IWDG files:**
- `Core/Inc/iwdg.h` - Header with configuration:
  - Prescaler = 256, Reload = 624
  - Timeout = (256 √ó 625) / 32000 = **5 seconds**
- `Core/Src/iwdg.c` - Implementation:
  - `MX_IWDG1_Init()` - Initializes IWDG1 peripheral
  - `watchdog_refresh()` - Wrapper for `HAL_IWDG_Refresh()`

**2. Modified files to add watchdog refresh:**

| File | Changes |
|------|---------|
| `main.c` | Added `#include "iwdg.h"`, `MX_IWDG1_Init()` call, refresh in main loop |
| `interface.c` | Added include, 9 waiting loops with refresh |
| `games.c` | Added include, 8 waiting loops with refresh |
| `basic_operations.c` | Added include, 8 loops (sensor waits, homing, flap adjust) |
| `tests.c` | Added include, 2 infinite loops with refresh |
| `buttons.c` | Added include, button release wait loop |

**3. Added watchdog test menu:**
- Added `TEST_WATCHDOG` to `item_code_t` enum in `utilities.h`
- Added to `maintenance_level_2_items[]` in `interface.c`
- Added `test_watchdog_menu` definition and to `menu_list[]`
- Added `test_watchdog()` function in `tests.c`
- Added case handler in `main.c`
- Added declaration in `tests.h`

**Menu Location:** MAINTENANCE ‚Üí (long press) ‚Üí Technical Support Only ‚Üí Test Watchdog

**Test Behavior:**
1. Prompts "Device will reset in 5 seconds - Proceed?"
2. If confirmed, displays countdown message
3. Enters infinite loop without `watchdog_refresh()`
4. Device resets after ~5 seconds

#### Testing Instructions:

**Normal Operation Test:**
1. Build and flash via ST-LINK
2. Verify normal operation (device should not reset unexpectedly)
3. Navigate menus, play games, etc. - all should work normally

**Watchdog Reset Test:**
1. Navigate to: MAINTENANCE ‚Üí (long press ENTER) ‚Üí Technical Support Only
2. Select "Test Watchdog"
3. Confirm when prompted
4. Device should display message and reset after ~5 seconds

#### Git Status:
- Committed: `09ff4cd` on `patch` branch
- Pushed to GitHub

#### Note for Future:
If build fails due to missing IWDG HAL driver:
1. Open `.ioc` in STM32CubeMX
2. Enable IWDG1 under System Core
3. Generate code
4. Re-apply the manual changes to generated files

---

### 2025-01-05: Session 10 - Encrypted Bootloader Phase 1 Setup

#### Completed:

**1. Created `Bootloader_E/` project** (encrypted bootloader):
- Copied from `Bootloader/`
- Renamed project to `LeShuffler_Bootloader_E`
- Updated `.project` and `.cproject` files

**2. Added HAL drivers for crypto peripherals:**
- `stm32h7xx_hal_cryp.c/h` + `_ex` variants (AES-256)
- `stm32h7xx_hal_hash.c/h` + `_ex` variants (SHA-256)
- `stm32h7xx_hal_rng.c/h` + `_ex` variants (Random number generator)
- Source: Copied from SBSFU_SDK

**3. Enabled HAL modules** (`stm32h7xx_hal_conf.h`):
```c
#define HAL_CRYP_MODULE_ENABLED
#define HAL_HASH_MODULE_ENABLED
#define HAL_RNG_MODULE_ENABLED
```

**4. Added micro-ecc library** (ECDSA-P256):
- `uECC.c` - Main library (downloaded from GitHub)
- `uECC.h` - Header (modified to include config)
- `uECC_config.h` - STM32H7 optimized config (P-256 only, arm_thumb2)

**5. Created crypto module:**
- `crypto.h` - API for AES-256-CBC, SHA-256, ECDSA-P256
- `crypto.c` - Implementation using HAL + micro-ecc
- `crypto_keys.h` - Test keys (AES-256 + ECDSA public key)

**6. Created peripheral initialization:**
- `cryp.c/h` - CRYP peripheral init
- `hash.c/h` - HASH peripheral init
- `rng.c/h` - RNG peripheral init

**7. Updated `main.c`:**
- Added includes for cryp, hash, rng, crypto
- Added init calls: `MX_CRYP_Init()`, `MX_HASH_Init()`, `MX_RNG_Init()`, `Crypto_Init()`

#### Import Project in STM32CubeIDE:
1. File ‚Üí Import ‚Üí General ‚Üí Existing Projects into Workspace
2. Browse to `LeShuffler/Bootloader_E/`
3. Select `LeShuffler_Bootloader_E`
4. Click Finish

#### Next Steps:
1. Build and fix any compilation errors
2. Test crypto functions
3. Modify bootload.c for encrypted packet handling
4. Create encrypt_firmware.py tool

---

### IMPORTANT: STM32CubeMX Code Generation Warning

**DO NOT modify the `.ioc` file in `Bootloader_E/`!**

STM32CubeMX will overwrite manually-added code when regenerating. The following files have manual modifications that would be LOST:

| File | Risk | Manual Changes |
|------|------|----------------|
| `stm32h7xx_hal_conf.h` | **HIGH** | `HAL_CRYP_MODULE_ENABLED`, `HAL_HASH_MODULE_ENABLED`, `HAL_RNG_MODULE_ENABLED` |
| `cryp.c/h` | **HIGH** | Entire file manually created |
| `hash.c/h` | **HIGH** | Entire file manually created |
| `rng.c/h` | **HIGH** | Entire file manually created |
| `main.c` | Medium | Init calls (inside USER CODE sections are safe) |

**Safe files** (won't be overwritten):
- `crypto.c/h`, `crypto_keys.h` - Custom files
- `uECC.c/h`, `uECC_config.h` - Third-party library
- `bootload.c/h` - Custom module

**If you MUST regenerate code:**
1. Backup these files first:
   - `Core/Inc/stm32h7xx_hal_conf.h`
   - `Core/Inc/cryp.h`, `Core/Src/cryp.c`
   - `Core/Inc/hash.h`, `Core/Src/hash.c`
   - `Core/Inc/rng.h`, `Core/Src/rng.c`
2. Regenerate code
3. Restore the backed-up files
4. Re-add any init calls in main.c

**Recommended approach:** Keep `Bootloader_E/.ioc` frozen. Make peripheral changes in `Bootloader/` first, test, then manually port to `Bootloader_E/`.

---

### 2025-01-05: Session 11 - Encrypted Packet Handling Integration

#### Completed:

**1. Added incremental hashing to crypto module:**
```c
// For signature verification over large data (can't store all in RAM)
int32_t Crypto_SHA256_Start(void);
int32_t Crypto_SHA256_Update(const uint8_t *data, uint32_t length);
int32_t Crypto_SHA256_Finish(uint8_t *hash);
int32_t Crypto_ECDSA_VerifyHash(const uint8_t *hash, const uint8_t *signature);
```

**2. Added encrypted packet types** (`bootload.h`):
```c
#define PACKET_TYPE_ENC_START  0x10  // Contains SFU header
#define PACKET_TYPE_ENC_DATA   0x11  // Contains encrypted data chunk
#define PACKET_TYPE_ENC_END    0x12  // Triggers signature verification
```

**3. Integrated encrypted packet handling** (`bootload.c`):

| Packet | Handler |
|--------|---------|
| `ENC_START` | Parse SFU header, validate magic, init IV, start hash, erase flash |
| `ENC_DATA` | Update hash, decrypt via AES-256-CBC, write to flash |
| `ENC_END` | Finalize hash, verify ECDSA signature, complete or error |

**4. Bootloader version bumped to v3.0**

#### Flash Size Expansion:

The encrypted bootloader with crypto code exceeded the original 48KB limit (~56KB needed).

**Changes to linker script** (`STM32H733VGTX_BOOTLOADER.ld`):
```
FLASH: 48K ‚Üí 128K  (full sector 0)
Version address: 0x0800BFF0 ‚Üí 0x0801FFF0
```

**Memory Layout Comparison:**

| Version | Bootloader Size | Version Address | App Start |
|---------|-----------------|-----------------|-----------|
| v2.x | 48KB (0x08000000-0x0800BFFF) | 0x0800BFF0 | 0x08020000 |
| v3.0 | 128KB (0x08000000-0x0801FFFF) | 0x0801FFF0 | 0x08020000 |

#### Backward Compatibility:

| Scenario | Works? | Notes |
|----------|--------|-------|
| v3.0 bootloader + plain .bin | ‚úÖ Yes | Original START/DATA/END still work |
| v3.0 bootloader + encrypted .sfu | ‚úÖ Yes | New ENC_* packet types |
| Old app reading v3.0 version | ‚ö†Ô∏è Partial | Gets 0 (old address has code/garbage) |

**Application version reading fix** (for future app update):
```c
uint16_t GetBootloaderVersion(void) {
    // Try v3.0 address first
    uint32_t magic = *(volatile uint32_t*)(0x0801FFF0 + 4);
    if (magic == 0x424C5652) return *(volatile uint16_t*)0x0801FFF0;
    // Fall back to v2.x address
    magic = *(volatile uint32_t*)(0x0800BFF0 + 4);
    if (magic == 0x424C5652) return *(volatile uint16_t*)0x0800BFF0;
    return 0;
}
```

#### Build Status:
- ‚úÖ Clean build (0 errors, 0 warnings)
- Binary size: ~57KB (fits in 128KB sector)

#### Git Commit:
```
537dfce  Bootloader_E: Add crypto infrastructure (compiles, untested)
```

#### Protocol Flow (Encrypted Update):
```
1. Python: Send ENC_START with SFU header (magic, sizes, IV, signature)
2. Bootloader: Validate header, init CBC decrypt, start SHA-256 hash
3. Python: Send ENC_DATA packets with encrypted chunks (256 bytes each)
4. Bootloader: Hash encrypted data, decrypt, write to flash
5. Python: Send ENC_END
6. Bootloader: Finalize hash, verify ECDSA-P256 signature
7. If valid ‚Üí FW_COMPLETE; if invalid ‚Üí FW_ERROR
```

#### Next Steps:
1. Create `encrypt_firmware.py` tool
2. Create `firmware_updater_encrypted.py`
3. End-to-end test with real firmware

---

### 2025-01-05: Session 12 - Encryption Tools & Testing

#### Completed:

**1. Created `encrypt_firmware.py`** (`Tools/encrypt_firmware.py`):
- Generates AES-256 + ECDSA-P256 key pairs (`--generate-keys`)
- Encrypts .bin firmware with AES-256-CBC
- Signs encrypted data with ECDSA-P256
- Outputs .sfu files matching bootloader's `SFU_Header_t`

**Usage:**
```bash
# Generate keys (one time)
python encrypt_firmware.py --generate-keys test_keys.json

# Encrypt firmware
python encrypt_firmware.py firmware.bin firmware.sfu --keys test_keys.json
```

**2. Created `firmware_updater_encrypted.py`** (`Tools/firmware_updater_encrypted.py`):
- Reads .sfu files and validates header
- Detects bootloader version (requires v3.0+)
- Sends encrypted packets: ENC_START ‚Üí ENC_DATA ‚Üí ENC_END
- Handles USB reconnection with restart capability

**Usage:**
```bash
python firmware_updater_encrypted.py              # Interactive
python firmware_updater_encrypted.py COM5         # Direct
python firmware_updater_encrypted.py --file x.sfu # Custom file
```

**3. Generated test keys:**
- `Tools/test_keys.json` - Contains AES-256 key + ECDSA key pair
- Updated `Bootloader_E/Core/Inc/crypto_keys.h` with matching public key

**4. Created test encrypted firmware:**
```bash
cd Tools
python encrypt_firmware.py ../Debug/LeShuffler.bin LeShuffler.sfu --keys test_keys.json
```
Output: 224,468 bytes (.sfu file)

#### Testing on macOS (partial):

**First attempt:**
- ‚úÖ Bootloader v3.0 detected
- ‚úÖ Header validated, flash erased
- ‚úÖ Started sending 877 encrypted packets
- ‚ùå USB disconnected mid-transfer
- ‚ùå On reconnect: "ENC_START failed: Header validation failed"

**Root cause:** After USB disconnect, the HASH peripheral was still in busy state from interrupted incremental hashing. `Crypto_SHA256_Start()` failed on retry.

#### Bug Fix Applied:

**1. Added `Crypto_Reset()` function** (`crypto.c`):
```c
void Crypto_Reset(void) {
    /* Reset incremental hash state */
    hash_started = 0;

    /* De-init and re-init HASH peripheral to clear any busy state */
    HAL_HASH_DeInit(&hhash);
    hhash.Init.DataType = HASH_DATATYPE_8B;
    HAL_HASH_Init(&hhash);

    /* De-init and re-init CRYP peripheral */
    HAL_CRYP_DeInit(&hcryp);
}
```

**2. Added declaration** (`crypto.h`):
```c
void Crypto_Reset(void);  /* Reset crypto state after interrupted transfer */
```

**3. Call at start of ENC_START** (`bootload.c`):
```c
case PACKET_TYPE_ENC_START:
    {
        // Reset crypto state first (handles interrupted transfers)
        Crypto_Reset();
        encrypted_mode = 0;
        ...
    }
```

#### Files Modified:
- `Bootloader_E/Core/Inc/crypto.h` - Added `Crypto_Reset()` declaration
- `Bootloader_E/Core/Src/crypto.c` - Added `Crypto_Reset()` implementation
- `Bootloader_E/Core/Src/bootload.c` - Call `Crypto_Reset()` at ENC_START

#### Files Created:
- `Tools/encrypt_firmware.py` - Developer encryption tool
- `Tools/firmware_updater_encrypted.py` - User update tool
- `Tools/test_keys.json` - Test key pair
- `Tools/LeShuffler.sfu` - Test encrypted firmware

#### Workflow Summary:

**Developer (you):**
```
LeShuffler.bin ‚Üí encrypt_firmware.py ‚Üí LeShuffler.sfu
                 (with production keys)
```

**End User:**
```
LeShuffler.sfu ‚Üí firmware_updater_encrypted.py ‚Üí Device
                 (just runs updater, no keys needed)
```

#### Next Steps:
1. Rebuild Bootloader_E with `Crypto_Reset()` fix
2. Re-flash via ST-LINK
3. Re-test encrypted update (try from Windows for stable USB)
4. Once working, commit changes to `encrypted` branch

---

### 2025-01-05: Session 12 (continued) - Debugging Encrypted Transfer

#### Problem:
After initial `Crypto_Reset()` fix, encrypted updates still failed. Multiple issues discovered:

#### Issues Found & Fixed:

**1. CRC Bug in Python Script** (CRITICAL):
```python
# OLD (broken) - CRC was always 0!
crc = 0
packet = struct.pack('<III', PACKET_TYPE_ENC_DATA, address, length)
packet += struct.pack('<I', crc)

# NEW (fixed) - CRC of encrypted data
import binascii
crc = binascii.crc32(data) & 0xFFFFFFFF
packet = struct.pack('<III', PACKET_TYPE_ENC_DATA, address, length)
packet += struct.pack('<I', crc)
```
**File:** `Tools/firmware_updater_encrypted.py` - `send_enc_data_packet()`

**2. Watchdog Timeout** (device reset mid-transfer):
- App's IWDG continues running in bootloader (cannot be stopped once started)
- Added `IWDG_REFRESH()` macro and calls throughout bootloader

**Files modified:**
| File | Changes |
|------|---------|
| `Bootloader_E/Core/Inc/main.h` | Added `#define IWDG_REFRESH() do { IWDG1->KR = 0xAAAA; } while(0)` |
| `Bootloader_E/Core/Src/main.c` | Added refresh in main loop, beep loops, timeout handling |
| `Bootloader_E/Core/Src/bootload.c` | Added refresh in all packet handlers, flash write loops |

**3. HASH Peripheral Recovery** (`Crypto_SHA256_Start()`):
```c
int32_t Crypto_SHA256_Start(void) {
    hhash.Init.DataType = HASH_DATATYPE_8B;

    /* Try init - if fails, RCC reset and retry */
    if (HAL_HASH_Init(&hhash) != HAL_OK) {
        __HAL_RCC_HASH_FORCE_RESET();
        for (volatile int i = 0; i < 100; i++);
        __HAL_RCC_HASH_RELEASE_RESET();

        hhash.State = HAL_HASH_STATE_RESET;
        hhash.Init.DataType = HASH_DATATYPE_8B;

        if (HAL_HASH_Init(&hhash) != HAL_OK) {
            return CRYPTO_ERROR;
        }
    }
    hash_started = 1;
    return CRYPTO_OK;
}
```

**4. Buffer Alignment Issues** (CRITICAL - caused hard fault/crash):

STM32H7 HAL_CRYP functions cast `uint8_t*` to `uint32_t*`, requiring 4-byte alignment.
All crypto buffers were plain `uint8_t[]` without alignment guarantees.

**Fix:** Added `__attribute__((aligned(4)))` to all crypto buffers:

| File | Buffer | Fix |
|------|--------|-----|
| `crypto_keys.h` | `AES_KEY[32]` | Added alignment attribute |
| `crypto_keys.h` | `ECDSA_PUBLIC_KEY[64]` | Added alignment attribute |
| `crypto.c` | `crypto_temp_buffer[16]` | Added alignment attribute |
| `bootload.c` | `packet_buffer[288]` | Added alignment attribute |
| `bootload.c` | `current_iv[16]` | Added alignment attribute |
| `bootload.c` | `decrypted_buffer[256]` | Added alignment attribute |
| `bootload.c` | `aligned_enc_buffer[256]` | **NEW** - aligned copy of input |

**ENC_DATA handler updated:**
```c
// Copy encrypted data to aligned buffer before crypto
memcpy(aligned_enc_buffer, packet->data, packet->length);

// Use aligned buffers for all crypto operations
Crypto_SHA256_Update(aligned_enc_buffer, packet->length);
Crypto_DecryptFirmwareBlock(aligned_enc_buffer, decrypted_buffer, ...);
```

#### Debugging Timeline:

| Symptom | Cause | Fix |
|---------|-------|-----|
| ENC_START fails on retry | HASH peripheral stuck busy | `Crypto_Reset()` + RCC recovery |
| Device resets mid-transfer | Watchdog timeout | Added `IWDG_REFRESH()` everywhere |
| 0% transferred, immediate fail | CRC always 0 | Fixed CRC calculation in Python |
| Crash/reset loop after CRC fix | Unaligned buffer access | Added `__attribute__((aligned(4)))` |

#### Key Insight from User:
> "Because the non-encrypted version works, can we focus on the differences?"
> "0% transferred vs 20% is qualitative, not quantitative"

This led to finding the CRC bug (immediate failure vs gradual progress).

#### Files Modified (this session):
- `Bootloader_E/Core/Inc/main.h` - IWDG_REFRESH macro
- `Bootloader_E/Core/Src/main.c` - Watchdog refresh calls
- `Bootloader_E/Core/Src/bootload.c` - Watchdog + alignment + aligned input buffer
- `Bootloader_E/Core/Src/crypto.c` - RCC reset recovery + buffer alignment
- `Bootloader_E/Core/Inc/crypto_keys.h` - Key alignment
- `Tools/firmware_updater_encrypted.py` - CRC fix

#### Testing Status:
- Awaiting rebuild and test with alignment fixes

#### Test Command:
```bash
python3 /Users/fs/Dropbox/Documents/LeShuffler/Product_Design/Software/LeShuffler/Tools/firmware_updater_encrypted.py \
  /Users/fs/Dropbox/Documents/LeShuffler/Product_Design/Software/LeShuffler/Core/Debug/LeShuffler.sfu
```

---

### 2025-01-05: Session 13 - USB Disconnect Debugging

#### Problem:
Encrypted firmware updates fail on macOS with 0% transferred:
- ENC_START succeeds (header validated, flash erased)
- First ENC_DATA packet ‚Üí immediate USB disconnect
- Device sometimes doesn't reconnect at all (15 second timeout)

#### Root Cause Analysis:
The non-encrypted bootloader works reliably on macOS, so the issue is specific to the crypto path. Two scenarios observed:
1. **USB disconnect + reconnect fails**: Second ENC_START fails after reconnect
2. **USB disconnect + no reconnect**: Device stuck/crashed

#### Fixes Applied (Session 13):

**1. USB Packet Assembly Buffer Clear** (`usbd_cdc_if.c`):
```c
static int8_t CDC_Init_FS(void) {
    USBD_CDC_SetTxBuffer(&hUsbDeviceHS, UserTxBufferFS, 0);
    USBD_CDC_SetRxBuffer(&hUsbDeviceHS, UserRxBufferFS);

    // CRITICAL: Clear packet assembly state on USB reconnect
    // Prevents leftover bytes from corrupting new packets
    rx_buffer_index = 0;
    packet_ready = 0;

    return USBD_OK;
}
```

**2. Safer Crypto Reset** (`crypto.c`):
```c
void Crypto_Reset(void) {
    hash_started = 0;
    cryp_configured = 0;

    /* Use HAL DeInit instead of aggressive RCC reset */
    HAL_HASH_DeInit(&hhash);
    hhash.State = HAL_HASH_STATE_RESET;

    HAL_CRYP_DeInit(&hcryp);
}
```
Note: Previously tried RCC reset which may have caused device to hang.

**3. Diagnostic Beeps in ENC_START** (`bootload.c`):
Added beep patterns to identify exact failure point:
| Beeps | Meaning |
|-------|---------|
| 1 short | ENC_START received |
| 2 | Packet length error |
| 3 | SFU magic mismatch |
| 4 | Firmware size out of bounds |
| 5 | Crypto_SHA256_Start() failed |
| 1 short (after SHA256) | About to erase flash |
| 6 | Flash erase failed |
| 1 long | ENC_START complete success |

#### Current Changes Summary (vs initial Bootloader_E):

| File | Change |
|------|--------|
| `crypto_keys.h` | `__attribute__((aligned(4)))` on AES_KEY, ECDSA_PUBLIC_KEY |
| `crypto.c` | Aligned buffers, state tracking, HAL DeInit in Reset |
| `cryp.c` | Dummy key/IV instead of NULL |
| `bootload.c` | Aligned buffers, aligned_enc_buffer, diagnostic beeps |
| `usbd_cdc_if.c` | Clear packet assembly state in CDC_Init_FS, debug beep |
| `firmware_updater_encrypted.py` | CRC bug fix |

#### Testing Status:
- **macOS**: USB disconnects on first ENC_DATA packet (0% transferred)
- **Windows**: Testing required to isolate if macOS-specific issue

#### Next Step:
**Test on Windows** to determine if this is a macOS USB issue or a code bug.
- If Windows works ‚Üí macOS USB workaround needed
- If Windows fails ‚Üí debug the ENC_DATA crypto/flash path

#### Files to Transfer for Windows Test:
1. Rebuild `Bootloader_E` and flash via ST-LINK
2. Use `Tools/firmware_updater_encrypted.py`
3. Use `Tools/LeShuffler.sfu` (or regenerate with `encrypt_firmware.py`)

---

### 2025-01-05: Session 14 - Incremental ENC_DATA Debugging

#### Approach:
Stripped ENC_DATA handler to minimum and re-added features incrementally to isolate the issue.

#### Testing Results (macOS):

| Step | Features | Result |
|------|----------|--------|
| 1 | Validation + CRC only | ‚úÖ 100% transferred (with reconnects) |
| 2 | + Hash update (`Crypto_SHA256_Update`) | üîÑ Testing on Windows |
| 3 | + Decrypt | Pending |
| 4 | + Flash write | Pending |

#### Key Finding:
With just validation + CRC (no crypto, no flash), transfer completes successfully but:
- macOS has USB disconnects (random 7-22%)
- Reconnection now works (after `CDC_ClearPacketState()` fixes)
- Restarts from 0% (cannot resume encrypted transfers due to hash state)
- Signature verification fails (expected - hash wasn't updated)

#### USB Disconnect Recovery Fixes:

**1. CDC_DeInit_FS** - Clear buffer on USB disconnect:
```c
static int8_t CDC_DeInit_FS(void) {
    rx_buffer_index = 0;
    packet_ready = 0;
    return USBD_OK;
}
```

**2. CDC_Receive_FS** - Defensive clear when receiving ENC_START:
```c
if (rx_buffer_index == 0 && bytes_received > 0) {
    if (Buf[0] == 0x11) {  // PACKET_TYPE_ENC_START
        packet_ready = 0;
    }
}
```

**3. ENC_START Handler** - Clear packet state at start:
```c
case PACKET_TYPE_ENC_START:
    {
        CDC_ClearPacketState();  // Clear before processing
        Crypto_Reset();
        ...
    }
```

#### Why Encrypted Updates Cannot Resume Mid-Transfer:
1. **SHA-256 hash is cumulative** - must hash all packets in order
2. **AES-CBC uses chained IV** - each block depends on previous ciphertext
3. **Signature is over entire encrypted payload** - partial data = wrong hash

**Conclusion:** Encrypted updates must restart from 0% on disconnect. This is by design.

#### macOS USB Instability:
- Random disconnects during transfer (7%, 11%, 22%, etc.)
- Not related to code - works fine on Windows
- **Recommendation:** Use Windows for encrypted firmware updates

#### Current ENC_DATA Handler (Step 2):
```c
case PACKET_TYPE_ENC_DATA:
    // Validation + CRC + Hash update (no decrypt, no flash)
    {
        IWDG_REFRESH();

        // State + length checks...

        // CRC check
        uint32_t enc_crc = software_crc32(packet->data, packet->length);
        if (enc_crc != packet->crc32) { ... }

        // Update hash with encrypted data
        if (Crypto_SHA256_Update(packet->data, packet->length) != CRYPTO_OK) { ... }

        // Increment counters
        enc_received_bytes += packet->length;
        fw_received_bytes += packet->length;

        return 0;
    }
```

#### Next Steps:
1. **Switch to Windows** for stable USB connection
2. Test Step 2 (hash update) - should pass signature verification
3. If Step 2 works, add Step 3 (decrypt)
4. Then Step 4 (flash write)
5. Complete end-to-end encrypted update

#### Note:
Bootloader is already flashed on device. Just need to run the updater on Windows.

---

### 2025-01-05: Session 15 - Windows Testing & Signature Verification Failure

#### Test Environment:
- Switched from macOS to Windows PC for stable USB connection
- Dropbox sync in progress (caution: files may not be fully synced)

#### Windows Test Results:
```
Firmware file: C:\Users\Francois\Desktop\Tools\LeShuffler.sfu
Bootloader version: v3.0 (encrypted)
Sending 877 encrypted packets...
[========================================] 100% (224368/224368)

ENC_END failed: Signature verification failed
```

#### Key Finding:
- ‚úÖ 100% transfer completed (no USB disconnects on Windows!)
- ‚úÖ All 877 packets transferred successfully
- ‚úÖ All CRC checks passed
- ‚ùå Signature verification failed at ENC_END

This confirms macOS USB instability was the transfer issue. Windows transfers reliably.

#### Root Cause Analysis:

**What we verified:**
1. **Keys match** - `test_keys.json` and `crypto_keys.h` have identical public key bytes
2. **Header structure correct** - Both Python and bootloader use same 100-byte SFU_Header_t
3. **Current ENC_DATA handler** (Step 2) only does:
   - Validation + CRC check
   - Hash update via `Crypto_SHA256_Update(packet->data, packet->length)`
   - Counter increment

**Possible causes:**
1. **Hash computation mismatch** - Incremental STM32 hash != Python single-shot hash
2. **micro-ecc library issue** - Signature format or verification bug
3. **File sync issue** - .sfu file may differ between machines

#### Debug Tool Created:
Created `Tools/debug_verify_sfu.py` to:
- Compute SHA-256 hash of encrypted data locally
- Verify ECDSA signature using same keys
- Output hash bytes for comparison with bootloader

**Usage:**
```bash
python debug_verify_sfu.py LeShuffler.sfu
```

If Python verification succeeds, the issue is in bootloader's hash or ECDSA code.

#### Files Created:
- `Tools/debug_verify_sfu.py` - Local signature verification tool

#### Next Steps:
1. **Wait for Dropbox sync to complete**
2. Run `debug_verify_sfu.py` on the exact .sfu file used in test
3. If Python verifies OK:
   - Add debug output to bootloader to show computed hash
   - Compare with Python's hash
4. If hashes match but signature fails:
   - Debug micro-ecc library / signature format

#### Technical Notes:

**Python signing process** (`encrypt_firmware.py`):
```python
encrypted_firmware = encryptor.update(padded_firmware) + encryptor.finalize()
digest = hashlib.sha256(encrypted_firmware).digest()
signature = private_key.sign(digest, ECDSA(Prehashed(SHA256())))
```

**Bootloader verification** (`bootload.c`):
```c
// ENC_DATA: Accumulate hash of each chunk
Crypto_SHA256_Update(packet->data, packet->length);

// ENC_END: Finalize and verify
Crypto_SHA256_Finish(computed_hash);
Crypto_ECDSA_VerifyHash(computed_hash, sfu_header.signature);
```

Both should produce identical SHA-256 hash over the encrypted data.

#### Important:
- Bootloader v3.0 is already flashed on device (from macOS session)
- The .sfu file at `C:\Users\Francois\Desktop\Tools\LeShuffler.sfu` was used for this test
- Must verify this .sfu matches the one in Dropbox after sync completes

---

### 2025-01-06: Session 16 - Factory Programming Strategy & RDP Protection

#### Factory Programming (Decided):

**Option A: Flash unencrypted .bin via ST-LINK**
- Use `stlink_flasher.py` or STM32CubeProgrammer directly
- Flash bootloader at 0x08000000
- Flash application at 0x08020000
- Firmware stored unencrypted in flash (this is normal for most embedded devices)

**Encryption protects transfer, not storage:**
- The .sfu (encrypted) format protects firmware during USB transfer
- Prevents interception/modification during update
- Once on device, firmware is decrypted and stored as plain code
- Physical access to device with RDP0 = flash readable (hence RDP protection needed)

#### RDP (Read Protection) Levels:

| Level | Protection | Reversible | Use Case |
|-------|------------|------------|----------|
| **RDP 0** | None - flash readable via debugger | N/A | Development |
| **RDP 1** | Flash protected, debug blocked | Yes (erases flash) | **Production - Recommended** |
| **RDP 2** | Permanently locked | **NO - IRREVERSIBLE** | High-security (proceed with caution) |

#### RDP Level 1 (Recommended):
- Blocks debugger from reading flash (protects firmware)
- Can revert to RDP 0 **but triggers full flash erase**
- This means: device can be recovered/reprogrammed but loses all content
- OTA updates via USB bootloader still work normally
- **Safe choice** - if bootloader has a bug, ST-LINK can still erase and re-flash

#### RDP Level 2 (High Security - IRREVERSIBLE):
- Permanently blocks ALL debug access
- Cannot be reverted - **EVER**
- OTA updates still work (CPU runs normally)
- **DANGER**: If bootloader has a critical bug ‚Üí device is permanently bricked
- Only use after extensive testing of bootloader

#### Recommendation:
Start with **RDP Level 1** for production:
```bash
# Using stlink_flasher.py
LeShuffler_STLink_Flasher.exe --rdp 1

# Or STM32CubeProgrammer CLI
STM32_Programmer_CLI -c port=SWD -ob RDP=0xBB
```

Only consider RDP Level 2 after:
1. Bootloader tested extensively (100+ updates)
2. Watchdog verified working
3. All edge cases handled
4. You're 100% confident in bootloader stability

#### RDP Values:
| Level | Option Byte Value | STM32CubeProgrammer |
|-------|-------------------|---------------------|
| 0 | 0xAA | `RDP=0xAA` |
| 1 | 0xBB (or any except 0xAA/0xCC) | `RDP=0xBB` |
| 2 | 0xCC | `RDP=0xCC` (‚ö†Ô∏è IRREVERSIBLE) |

#### RDP Level 1 - Detailed Explanation

**What's BLOCKED (debug access):**
| Action | Status |
|--------|--------|
| Read flash via debugger (ST-LINK) | ‚ùå Blocked |
| Read RAM via debugger | ‚ùå Blocked |
| Read option bytes via debugger | ‚ùå Blocked |
| JTAG/SWD memory access | ‚ùå Blocked |

**What's ALLOWED (normal operation):**
| Action | Status |
|--------|--------|
| CPU executes code normally | ‚úÖ Works |
| Bootloader runs | ‚úÖ Works |
| USB CDC works | ‚úÖ Works |
| OTA updates via bootloader | ‚úÖ Works |
| Flash write from running code (HAL_FLASH_Program) | ‚úÖ Works |
| Connect debugger (but can't read) | ‚úÖ Connects |
| Mass erase via debugger | ‚úÖ Works (reverts to RDP 0) |

**Key Point - "Connect but Can't Read":**
With RDP 1, ST-LINK can still connect to the chip. It just can't read anything.
If someone tries to read flash, they get all 0x00 or an error.

**Recovery Path (RDP 1 ‚Üí RDP 0):**
1. Connect ST-LINK
2. Request RDP level change to 0
3. Chip performs FULL MASS ERASE automatically
4. RDP goes to 0
5. Chip is now blank - can reprogram

This is the "escape hatch" - you lose all firmware, but the chip isn't bricked.

**RDP 2 Difference:**
With RDP 2, even the mass erase option is disabled. The chip is permanently locked.
No debug connection of any kind. No recovery possible.

**Practical Impact:**
| Scenario | RDP 0 | RDP 1 | RDP 2 |
|----------|-------|-------|-------|
| Attacker reads flash | ‚úÖ Can read | ‚ùå Can't read | ‚ùå Can't read |
| You find bootloader bug | Reprogram | Mass erase + reprogram | **Bricked forever** |
| User does OTA update | Works | Works | Works |
| Factory programming | Normal | Normal | Normal (but last step!) |

**Bottom line:** RDP 1 protects firmware from being read while keeping a recovery path.
RDP 2 burns that bridge permanently.

---

### 2025-01-06: Session 17 - HAL_CRYP Decrypt Debugging (ONGOING)

#### Problem:
Encrypted firmware transfers complete 100%, signature verification passes, but decrypted firmware is invalid (device stays in bootloader after reset).

#### Key Discovery - HAL_CRYP Hard Fault:

| Approach | Crash? | Output |
|----------|--------|--------|
| `HAL_CRYP_SetConfig` + `HAL_CRYP_Decrypt` | **No** | Wrong (garbage) |
| `HAL_CRYP_DeInit` + `HAL_CRYP_Init` + `HAL_CRYP_Decrypt` | **YES - Hard Fault** | N/A |
| Skip decrypt (memcpy only) | **No** | Transfer completes |

**Conclusion:** The crash is specifically in `HAL_CRYP_Decrypt` after `HAL_CRYP_Init` with our key.

#### Diagnostic Tests Performed:

1. **memcpy instead of decrypt** ‚Üí ‚úÖ No crash, transfer completes
2. **HAL_CRYP_Init alone** ‚Üí ‚úÖ Works (key loads OK)
3. **HAL_CRYP_Decrypt after Init** ‚Üí ‚ùå Hard fault
4. **HAL_CRYP_SetConfig + Decrypt** ‚Üí ‚úÖ No crash but wrong output

#### Attempted Fixes (all caused issues):

| Fix | Result |
|-----|--------|
| Keep CRYP clock enabled (don't disable in MspDeInit) | Still crashes |
| Use `HAL_CRYP_SetConfig` instead of Init | No crash, wrong output |
| Byte-swap key/IV for big-endian CRYP | Crash at 38% |
| Use `CRYP_DATATYPE_32B` | Device won't boot at all |

#### Current Safe State (reverted to):
```c
// SetConfig approach - doesn't crash
config.DataType = CRYP_DATATYPE_8B;
config.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ALWAYS;
HAL_CRYP_SetConfig(&hcryp, &config);

// Skip actual decrypt for now - just copy
memcpy(decrypted, encrypted, length);
```

#### Root Cause Analysis:

The SetConfig approach doesn't crash because it doesn't fully reinitialize the CRYP peripheral. But it produces wrong output because:
1. The key may not be properly loaded into hardware
2. The CRYP peripheral was initialized by `MX_CRYP_Init()` with dummy key
3. `SetConfig` updates the config struct but may not reload the key

The Init approach crashes because something about the full CRYP initialization with our real key triggers a hard fault.

#### Files Modified This Session:
- `crypto.c` - Multiple decrypt approaches tested
- `cryp.c` - Disabled clock disable in MspDeInit
- `firmware_updater_encrypted.py` - Improved error handling for USB disconnect

#### What's Working:
- ‚úÖ ENC_START (header validation, flash erase)
- ‚úÖ ENC_DATA (CRC check, hash update, transfer)
- ‚úÖ ENC_END (hash finalize, ECDSA signature verification)
- ‚úÖ Transfer completes 100% on Windows
- ‚úÖ Signature verification passes

#### What's NOT Working:
- ‚ùå AES-256-CBC decryption crashes or produces garbage
- ‚ùå Device stays in bootloader (invalid application in flash)

#### Next Steps:
1. Recover device via ST-LINK (flash known-good bootloader)
2. Investigate why HAL_CRYP_Decrypt crashes after HAL_CRYP_Init
3. Consider alternative: software AES implementation (no hardware CRYP)
4. Test with known AES test vectors to isolate encryption vs key format issue

#### Key Insight:
The signature verification passes because it verifies the **encrypted** data hash, not the decrypted output. So the crypto infrastructure (hash, ECDSA) works - only the AES decryption is failing.

---

### 2025-01-06: Session 18 - STM32H7 CRYP Byte Ordering Fix

#### Root Cause Identified:

**Research findings** from ST Community and documentation:
- STM32H7 CRYP expects key and IV as **big-endian 32-bit words**
- Even when using `CRYP_DATATYPE_8B` for data, key/IV format is separate
- When casting `uint8_t*` to `uint32_t*` on ARM (little-endian):
  - Bytes `F4 2C E6 9E` become word `0x9EE62CF4` (wrong!)
  - CRYP expects word `0xF42CE69E` (big-endian)

**Key quote from ST Community:**
> "if the key and the iv are converting from uint8_t to uint32_t (big endian) whilst keeping the data little endian the encryption succeeds."

#### Solution Implemented:

Added byte-to-big-endian-word conversion in `crypto.c`:

```c
/* Convert 4 bytes to big-endian 32-bit word (required by CRYP peripheral) */
static inline uint32_t bytes_to_be32(const uint8_t *bytes) {
    return ((uint32_t)bytes[0] << 24) |
           ((uint32_t)bytes[1] << 16) |
           ((uint32_t)bytes[2] << 8)  |
           (uint32_t)bytes[3];
}

/* Key and IV buffers as 32-bit words */
static uint32_t key_words[8];   // 32 bytes = 8 words
static uint32_t iv_words[4];    // 16 bytes = 4 words

int32_t Crypto_AES256_Decrypt(...) {
    /* Convert key from byte array to big-endian 32-bit words (only once) */
    if (!key_converted) {
        for (int i = 0; i < 8; i++) {
            key_words[i] = bytes_to_be32(&AES_KEY[i * 4]);
        }
        key_converted = 1;
    }

    /* Convert IV from byte array to big-endian 32-bit words (every call) */
    for (int i = 0; i < 4; i++) {
        iv_words[i] = bytes_to_be32(&iv[i * 4]);
    }

    /* Configure CRYP with properly formatted key and IV */
    config.pKey = key_words;
    config.pInitVect = iv_words;

    /* Perform AES-256-CBC decryption */
    HAL_CRYP_Decrypt(&hcryp, (uint32_t*)encrypted, length / 4,
                     (uint32_t*)decrypted, HAL_MAX_DELAY);
}
```

#### Files Modified:
- `Bootloader_E/Core/Src/crypto.c`:
  - Added `bytes_to_be32()` conversion function
  - Changed key/IV buffers from `uint8_t[]` to `uint32_t[]`
  - Key converted once (cached), IV converted each call (changes with CBC)
  - Now performs actual `HAL_CRYP_Decrypt` instead of memcpy

#### Technical Explanation:

**AES-256 Key (32 bytes) as stored in crypto_keys.h:**
```
F4 2C E6 9E C2 B8 24 5E D6 80 26 10 DD 26 2D 2D ...
```

**Wrong (direct cast on ARM little-endian):**
```
word[0] = 0x9EE62CF4  // bytes 3,2,1,0
word[1] = 0x5E24B8C2  // bytes 7,6,5,4
...
```

**Correct (big-endian conversion):**
```
word[0] = 0xF42CE69E  // bytes 0,1,2,3
word[1] = 0xC2B8245E  // bytes 4,5,6,7
...
```

#### Sources:
- [Hardware AES 256 CBC Incorrect results - ST Community](https://community.st.com/t5/stm32-mcus-security/hardware-aes-256-cbc-incorrect-results/td-p/245469)
- [A guide to the HAL of the AES accelerator - ST Community](https://community.st.com/t5/stm32-mcus-security/a-guide-to-the-hal-of-the-aes-accelerator-or-how-to-fix-it/td-p/134252)
- [STM32CubeH7 CRYP Examples - GitHub](https://github.com/STMicroelectronics/STM32CubeH7/blob/master/Projects/STM32H747I-EVAL/Examples/CRYP/CRYP_AESGCM/CM7/Src/main.c)

#### Test Result (First Attempt):
- ‚ùå Device unresponsive after update (decryption produced garbage)
- SetConfig doesn't trigger proper key derivation for decryption

#### Final Fix - Use HAL_CRYP_Init:
Changed from `HAL_CRYP_SetConfig` to `HAL_CRYP_Init`:

```c
/* Use HAL_CRYP_Init to properly initialize (triggers key derivation) */
hcryp.Init.DataType = CRYP_DATATYPE_8B;
hcryp.Init.KeySize = CRYP_KEYSIZE_256B;
hcryp.Init.Algorithm = CRYP_AES_CBC;
hcryp.Init.pKey = key_words;       // Big-endian formatted
hcryp.Init.pInitVect = iv_words;   // Big-endian formatted

/* Force reinitialization */
hcryp.State = HAL_CRYP_STATE_RESET;

if (HAL_CRYP_Init(&hcryp) != HAL_OK) return CRYPTO_ERROR;

/* Now decrypt works correctly */
HAL_CRYP_Decrypt(&hcryp, ...);
```

#### Test Result (After HAL_CRYP_Init fix):
- ‚úÖ **SUCCESS!** Encrypted firmware update complete
- ‚úÖ Device boots into decrypted firmware
- ‚úÖ All 877 packets transferred and decrypted correctly

#### Summary - Two Key Fixes Required:
1. **Big-endian byte ordering** for key and IV (`bytes_to_be32()`)
2. **HAL_CRYP_Init** instead of SetConfig (triggers proper key derivation)

#### Encrypted Bootloader v3.0 - WORKING:
- AES-256-CBC hardware decryption (STM32H7 CRYP)
- SHA-256 hash verification (STM32H7 HASH)
- ECDSA-P256 signature verification (micro-ecc library)
- USB CDC transfer with restart capability

---

### 2025-01-07: Session 19 - Firmware Version System & Key Security

#### Firmware Version System Implemented:

**Files Created:**
- `Core/Inc/version.h` - Version defines and getter declarations
- `Core/Src/version.c` - Version struct with magic number + getter functions

**Version Format:** Major.Minor.Patch (e.g., v1.0.1)
- Encoded as `0x00MMmmPP` (e.g., v1.0.1 = `0x00010001`)
- Magic number `0x46575652` ("FWVR") for external tool detection

**API:**
```c
const char* GetFirmwareVersionString(void);    // Returns "v1.0.1"
const char* GetFirmwareVersionDisplay(void);   // Returns "LeShuffler FW version 1.0.1"
uint32_t GetFirmwareVersion(void);             // Returns 0x00010001
```

**Files Modified:**
- `Core/Inc/definitions.h` - Removed `VERSION` define (moved to version.h)
- `Core/Inc/interface.h` - Changed `prompt_text()` to accept `const char*`
- `Core/Src/interface.c` - Added `#include <version.h>`, use `GetFirmwareVersionDisplay()`

**To Release New Version:** Edit only `Core/Inc/version.h`:
```c
#define FW_VERSION_MAJOR  1
#define FW_VERSION_MINOR  0
#define FW_VERSION_PATCH  2  // Change this
```

#### Key Security Improvements:

**Problem:** AES key in `crypto_keys.h` was committed to Git/synced to Dropbox.

**Cryptographic Keys Explained:**
| Key | Type | Purpose | Risk if Leaked |
|-----|------|---------|----------------|
| AES-256 | Symmetric | **Encryption** - prevents reverse engineering | Firmware can be decrypted |
| ECDSA Private | Asymmetric | **Signing** - proves firmware is authentic | Attacker can sign malicious FW |
| ECDSA Public | Asymmetric | **Verification** - bootloader verifies signature | None (meant to be public) |

**Solution Implemented:**

1. **Created template file:** `Bootloader_E/Core/Inc/crypto_keys.h.template`
   - Contains placeholder values
   - Committed to Git (safe)

2. **Removed real keys from Git:**
   ```bash
   git rm --cached Bootloader_E/Core/Inc/crypto_keys.h
   ```

3. **Updated `.gitignore`:**
   ```
   # Cryptographic keys
   *_keys.json
   *.pem
   Bootloader_E/Core/Inc/crypto_keys.h
   !*.template

   # Firmware binaries
   *.sfu
   ```

4. **Local key storage:** `/Users/fs/.leshuffler_keys/production_keys.json` (hidden folder, outside Dropbox)

5. **Backup:** Store `production_keys.json` in 1Password

#### Production Keys (ACTIVE):

Keys are generated and in use. To create .sfu files:
```bash
python3 Tools/encrypt_firmware.py Tools/LeShuffler.bin Tools/LeShuffler.sfu --keys /Users/fs/.leshuffler_keys/production_keys.json
```

**IMPORTANT:** Always use production keys for .sfu generation. The `test_keys.json` in Tools is for development only and does NOT match the bootloader.

#### Development Setup (if rebuilding Bootloader_E):

`crypto_keys.h` is gitignored. To build with production keys:
1. Copy keys from `/Users/fs/.leshuffler_keys/production_keys.json`
2. Paste `aes_key` array ‚Üí `AES_KEY[32]` in `crypto_keys.h`
3. Paste `ecdsa_public_key` array ‚Üí `ECDSA_PUBLIC_KEY[64]`
4. Rebuild Bootloader_E

#### Unified Firmware Updater:

**Current:** `Tools/firmware_updater.py` (v2.0 - renamed from firmware_updater_encrypted.py)

Now supports both file types with auto-fallback:
| File | Bootloader | Transfer Method |
|------|------------|-----------------|
| .sfu | v3.0+ | Encrypted (ENC_START/DATA/END) |
| .sfu | v1.x/v2.x | **Auto-fallback to .bin** if available |
| .bin | v3.0+ | Legacy (START/DATA/END) - backward compatible |
| .bin | v1.x/v2.x | Legacy (START/DATA/END) |

**Auto-fallback feature:** When a legacy bootloader is detected with an `.sfu` file,
the updater automatically switches to `LeShuffler.bin` (same folder) if available.
Bootloader version is detected FIRST, then the appropriate file is loaded and displayed.

**Default file search:** Looks for `LeShuffler.sfu` first, then `LeShuffler.bin`

#### RDP Development Workflow (Discussed):

| Phase | RDP Level | Keys | Why |
|-------|-----------|------|-----|
| Development | **RDP 0** | Test keys | Full debug access |
| Testing production | RDP 1 | Test keys | Verify RDP works, can mass-erase to recover |
| Production | **RDP 1** | Production keys | Ship to customers |

**RDP 1 allows:**
- Mass erase + reflash via ST-LINK (recovery path)
- OTA updates via bootloader (normal operation)

**RDP 1 blocks:**
- Reading flash via debugger (protects firmware)

#### Git Commit:
```
e5c2fc8  Add firmware version system and improve key security
```

**Changes included:**
- Firmware version system (version.h, version.c)
- crypto_keys.h removed from tracking + template added
- Updated .gitignore (keys, .sfu, binaries)
- Bootloader_E debug code removal
- Unified firmware updater (auto-fallback to .bin for legacy bootloaders)
- ST-LINK flasher updated (default bootloader: Bootloader_E.bin)

---

### 2025-01-08: Session 20 - Watchdog Fix & Limited Card Flap Adjustment

#### Watchdog Fix in dc_motors_run_in():

Added missing `watchdog_refresh()` calls to prevent device reset during motor run-in test.

**Files Modified:**
- `Motors/TB6612FNG.c`:
  - Added `#include <iwdg.h>`
  - Added `watchdog_refresh()` to button wait loop (line 394)
  - Note: First loop (countdown) already had it from earlier session

#### Limited Card Flap Adjustment Feature:

**Problem:** `adjust_card_flap()` was called from both MAINTENANCE and MAINTENANCE_LEVEL_2 menus with identical unlimited adjustment range.

**Requirement:** Limit adjustment to ¬±3 when called from MAINTENANCE menu, keep unlimited for MAINTENANCE_LEVEL_2.

**Solution:** Duplicate action menu with min/max parameters.

| Menu | Enum | Wrapper | Range |
|------|------|---------|-------|
| MAINTENANCE | `ADJUST_CARD_FLAP_LIMITED` | `adjust_card_flap_limited()` | -3 to +3 |
| MAINTENANCE_LEVEL_2 | `ADJUST_CARD_FLAP` | `adjust_card_flap_full()` | Unlimited |

**Files Modified:**

| File | Changes |
|------|---------|
| `Core/Inc/utilities.h:93` | Added `ADJUST_CARD_FLAP_LIMITED` to enum |
| `Core/Inc/basic_operations.h:124` | Updated `adjust_flap()` signature: `adjust_flap(uint32_t*, int8_t min, int8_t max)` |
| `Core/Src/basic_operations.c:1653` | Added min/max clamping logic to `adjust_flap()` |
| `Motors/servo_motor.h:36-38` | Updated `adjust_card_flap()` signature, added wrapper declarations |
| `Motors/servo_motor.c:157-191` | Updated function with min/max params, added `_limited()` and `_full()` wrappers |
| `Core/Src/interface.c:146` | Changed `maintenance_items[]` to use `ADJUST_CARD_FLAP_LIMITED` |
| `Core/Src/interface.c:350-351` | Added `adjust_card_flap_limited_menu` definition |
| `Core/Src/interface.c:395` | Added `&adjust_card_flap_limited_menu` to `menu_list[]` |
| `Core/Src/main.c:641-647` | Updated case handlers for both enums |

**Implementation Details:**

`adjust_flap()` now calculates allowed range from starting position:
```c
// Calculate min/max allowed positions (0,0 means no limit)
uint32_t min_pos = (min_adjust == 0 && max_adjust == 0) ? 0 :
        start_pos + min_adjust * FLAP_FACTOR;
uint32_t max_pos = (min_adjust == 0 && max_adjust == 0) ? UINT32_MAX :
        start_pos + max_adjust * FLAP_FACTOR;

// Clamp new position to range
if (new_pos < min_pos) new_pos = min_pos;
if (new_pos > max_pos) new_pos = max_pos;
```

**Wrapper Functions:**
```c
return_code_t adjust_card_flap_limited(void) {
    return adjust_card_flap(-3, 3);  // MAINTENANCE menu
}

return_code_t adjust_card_flap_full(void) {
    return adjust_card_flap(0, 0);   // MAINTENANCE_LEVEL_2 menu (0,0 = unlimited)
}
```

#### LCD Countdown Display Fix:

**Problem:** In `dc_motors_run_in()`, countdown numbers were superimposing (e.g., "59" visible under "58").

**Cause:** `BSP_LCD_FillRect` was clearing a centered area but `prompt_message()` draws at a different position.

**Fix:** Clear the full row width where countdown appears:
```c
// y position for the second line (where countdown appears)
uint16_t y_pos = LCD_TOP_ROW + LCD_ROW_HEIGHT * (MSG_ROW + 1) + V_ADJUST;

if (remaining_time != prev_remaining_time)
{
    // Clear the countdown line before redrawing
    BSP_LCD_SetTextColor(LCD_COLOR_BCKGND);
    BSP_LCD_FillRect(0, y_pos, BUTTON_ICON_X, LCD_ROW_HEIGHT);
    BSP_LCD_SetTextColor(LCD_COLOR_TEXT);
    prompt_message(display_buf);
    prev_remaining_time = remaining_time;
}
```

#### TMC2209 Watchdog Fix (Low Power Startup):

**Problem:** When device powered only by laptop USB (insufficient power for stepper motor), `carousel_init()` ‚Üí `tmc2209_init()` hangs indefinitely, triggering watchdog reset. Screen stays on last animation frame.

**Root Cause:** Inner `do-while` loops waiting for valid register reads had NO timeout or watchdog refresh:
```c
do
    check_bytes = tmc2209_read(ADDRESS_GCONF);
while ((check_bytes == 0xffffffff));  // Infinite loop if TMC2209 not responding
```

**Fix:** Added `watchdog_refresh()` to all inner loops in `Motors/TMC2209.c`:

| Function | Loop Location | Purpose |
|----------|---------------|---------|
| `tmc2209_init()` | GCONF read (lines 154-159) | Register config verification |
| `tmc2209_init()` | PWMCONF read (lines 177-182) | Register config verification |
| `tmc2209_init()` | CHOPCONF read (lines 201-206) | Register config verification |
| `tmc2209_set_standstill_mode()` | Read loop (lines 237-242) | Standstill mode change |
| `tmc2209_set_stepper_direction()` | Read loop (lines 253-259) | Direction change |
| `test_carousel_motor()` | Button wait (line 482) | Test function |
| `test_carousel_driver()` | Button wait (line 519) | Test function |

**Result:** Device now stays on animation screen without watchdog reset when underpowered.

#### Git Commits:
```
8d20162 Add watchdog refresh to TMC2209 driver loops
1503a4d Add limited card flap adjustment and fix watchdog in dc_motors_run_in
c2ee0c9 Merge branch 'patch'
```

#### Legacy Folder Reorganization:

Moved legacy (non-encrypted) files to `Legacy/` folder for clarity:

| From | To |
|------|-----|
| `Bootloader/` | `Legacy/Bootloader/` |
| `Tools/firmware_updater_v5_1.py` | `Legacy/Tools/firmware_updater_legacy.py` |
| `Tools/firmware_updater_encrypted.py` | `Tools/firmware_updater.py` |

**Current Project Structure:**
```
LeShuffler/
‚îú‚îÄ‚îÄ Bootloader_E/              # Current encrypted bootloader (v3.0)
‚îú‚îÄ‚îÄ Tools/
‚îÇ   ‚îú‚îÄ‚îÄ firmware_updater.py    # Main updater (encrypted + legacy fallback)
‚îÇ   ‚îú‚îÄ‚îÄ encrypt_firmware.py    # Creates .sfu files
‚îÇ   ‚îú‚îÄ‚îÄ stlink_flasher.py      # Factory ST-LINK flasher
‚îÇ   ‚îú‚îÄ‚îÄ LeShuffler.bin         # Plain firmware (for ST-LINK)
‚îÇ   ‚îú‚îÄ‚îÄ LeShuffler.sfu         # Encrypted firmware (for USB update)
‚îÇ   ‚îî‚îÄ‚îÄ LeShuffler_Bootloader_E.bin  # Bootloader binary
‚îú‚îÄ‚îÄ Legacy/
‚îÇ   ‚îú‚îÄ‚îÄ Bootloader/            # Non-encrypted bootloader (for old devices)
‚îÇ   ‚îî‚îÄ‚îÄ Tools/
‚îÇ       ‚îî‚îÄ‚îÄ firmware_updater_legacy.py  # Non-encrypted updater
‚îú‚îÄ‚îÄ Core/                      # Application firmware source
‚îî‚îÄ‚îÄ ...
```

**Git Commit:**
```
f815e39 Move legacy bootloader and updater to Legacy folder
```

---

### 2025-01-08: Session 21 - RDP1 Verification & v1.0.1 Release

#### RDP Level 1 Testing:
- ‚úÖ Set RDP1 via STM32CubeProgrammer (`RDP=0xBB`)
- ‚úÖ Application boots correctly with RDP1 active
- ‚úÖ Flash read blocked (debugger returns error)
- ‚úÖ USB firmware update works with encrypted .sfu file
- ‚úÖ Production keys verified working

#### Git Tag Created:
```
v1.0.1 - Production release with encrypted bootloader
```

**Release includes:**
- Encrypted USB firmware updates (AES-256-CBC + ECDSA-P256)
- Bootloader v3.0 with signature verification
- RDP Level 1 support for flash protection
- Firmware version system (v1.0.1)
- Watchdog protection throughout
- Limited card flap adjustment (¬±3) in MAINTENANCE menu
- Legacy bootloader support with auto-fallback

#### Factory Programming:
```bash
python stlink_flasher.py --rdp 1 -y
```

Files needed on production machine:
- `stlink_flasher.py`
- `LeShuffler.bin`
- `LeShuffler_Bootloader_E.bin`

Requirement: STM32CubeProgrammer installed

#### Next Step:
Create Windows executable for `firmware_updater.py` using PyInstaller (for field updates).

---

### STM32H7 HAL Notes

#### HASH Peripheral (STM32H7)
- **NO `Instance` member** in `HASH_HandleTypeDef` on STM32H7
- Unlike CRYP which has `hcryp.Instance = CRYP;`, HASH accesses the peripheral directly
- Just set `hhash.Init.DataType = HASH_DATATYPE_8B;` and call `HAL_HASH_Init(&hhash)`
- Clock enabled via `__HAL_RCC_HASH_CLK_ENABLE();` in `HAL_HASH_MspInit()`

#### CRYP Peripheral (STM32H7)
- **HAS `Instance` member**: `hcryp.Instance = CRYP;`
- Must also set `hcryp.Init.pKey`, `hcryp.Init.pInitVect`, `hcryp.Init.Algorithm`, etc.

#### Key Difference:
```c
// CRYP - needs Instance
hcryp.Instance = CRYP;
hcryp.Init.Algorithm = CRYP_AES_CBC;
HAL_CRYP_Init(&hcryp);

// HASH - NO Instance member
hhash.Init.DataType = HASH_DATATYPE_8B;
HAL_HASH_Init(&hhash);  // Accesses HASH peripheral directly
```

---

